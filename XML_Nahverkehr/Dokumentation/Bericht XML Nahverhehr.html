<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/html" xml:lang="en" lang="en">

<head>
<meta name="generator" content="HTML Tidy for Mac OS X (vers 25 March 2009), see www.w3.org">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Bericht XML Nahverkehr</title>

<style type="text/css">
/*<![CDATA[*/
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }


div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}
/*]]>*/
</style>
<link rel="stylesheet" type="text/css" href="Bericht%20XML%20Nahverkehr/W3C-REC.css">

<!-- table of contents -->
<link rel="contents" title="Table of Contents" href="#table_of_contents">
<!-- bookmarks -->
<link rel="bookmark" title="link" href="#dt-link">
<!-- sections -->
<link rel="section" href="#intro" title="1 Introduction">
</head>



<!-- begin of body -->
<body>
<div class="head">
<h1><a name="title" id="title"></a>Bericht zum XML Projekt Nahverkehr</h1>
<br><br><br><br><br><br><br><br><br><br><br><br>
<h3 style="font-size:28px; color:black">15.01.2014</h3>
<br><br><br><br><br><br><br><br><br><br><br><br>
<dl>
<h3 style="font-size:28px; color:black">Autoren:</h3>
<table style="font-size:24px">
  <tr>
    <td>Andreas Bögelein</td>
    <td style="padding-left:1cm">_____________________</td>
  </tr>
  <tr>
    <td>Marco Knappe</td>
    <td style="padding-left:1cm">_____________________</td>
  </tr>
  <tr>
    <td>Mateo Luzi</td>
    <td style="padding-left:1cm">_____________________</td>
  </tr>
</table>
<br><br><br>


<!-- begin of table_of_contents -->
<div class="toc">
<h2><a name="table_of_contents" id="table_of_contents"></a>Inhaltsverzeichnis</h2>
<div class="toc">
1 <a href="#einleitung">Einleitung</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;1.1 <a href="#grundlegendes-konzept">Grundlegendes Konzept</a><br>
2 <a href="#verwendete-technologien">Verwendete Technologien</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;2.1 <a href="#xml">XML</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;2.2 <a href="#dtd">DTD</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;2.3 <a href="#xslt">XSLT</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;2.4 <a href="#bootstrap">Bootstrap</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;2.5 <a href="#jquery">jQuery</a><br>
3 <a href="#konzept">Konzept</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.1 <a href="#datenhaltung">Datenhaltung</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.1 <a href="#datenhaltung-master">Master</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.2 <a href="#datenhaltung-stations">Stations</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.3 <a href="#datenhaltung-routes">Routes</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.4 <a href="#datenhaltung-schedules">Schedules</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.5 <a href="#datenhaltung-tickets">Tickets</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.6 <a href="#datenhaltung-drivers">Drivers</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.7 <a href="#datenhaltung-vehicles">Vehicles</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.2 <a href="#frontend">Frontend</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.1 <a href="#frontend-mockups">Mockups</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.2 <a href="#frontend-aufbau">Aufbau</a><br>
4 <a href="#fazit">Fazit</a><br>
<h3><a name="appendices" id="appendices"></a>Anhang</h3>
<div class="toc">A <a href="#quellen">Quellen</a><br>
</div>
</div>
</div>
</div>


<br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br>

<!-- begin of document body  -->
<div class="body">

<div class="div1">
<h2><a name="einleitung" id="einleitung"></a>1 Einleitung</h2>
<p>Dieser Bericht behandelt die grundlegende Verwendung der Auszeichnungsspache XML, wobei diese Abkürzung für Extensible Markup Language steht. XML wird im Weiteren zur hierarchischen Strukturierung von Daten hergenommen. Um diese im späteren Verlauf nutzerfreundlich zu Visualisieren wird eine Programmiersprache names XSL verwendet, die XML nach Html transformiert. So kann durch diese Extensible Stylesheet Language (XSL) ein umfangreiches Html-Dokument erstellt werden, das nicht nur statisch Daten anzeigen kann, sondern auch interaktiv die UI mitverändert.</p>

<div class="div2">
<h3><a name="grundlegendes-konzept" id="grundlegendes-konzept"></a>1.1 Grundlegendes Konzept</h3>
<p>Um nun die Verwendung von XML und XSL in einem Beispiel zu zeigen, haben wir hierfür ein Nahverkehrsystem modelliert. Dieses System soll über eine Datenhaltung verfügen, die alle Informationen zu Routen, Personal und Fahrzeugen speichert. Bei den verwendeten Daten in unserem Modell haben wir uns, vor allem bei Haltestellen und Routen, an das Verkehrsnetz des VGN orientiert. Da wir uns aber verstärkt auf Struktur und Darstellung unseres XML-Modells konzentriert haben, beschränkt sich die Menge der Daten auf ein Maß, welches ausreicht um unser Konzept sinnvoll darzustellen. Dieses Modell soll mit XML erstellt und durch DTDs (siehe <a href="#dtd">Abschnitt 2.2</a>) validiert werden.</p>
<p>Für die nutzerfreundliche Visualierung dieser Daten in diesem Projekt kommt daraufhin XSL zum Einsatz, um hieraus ein Html-Dokument zu generieren. Das Bedienkonzept, welches noch näher in <a href="#frontend">Abschnitt 3.2</a> erläutert wird, verfolgt dabei mehrere Views, die durch Tabs erreichbar sind. Jede dieser Views soll dabei einen unabhängigen Bereich der Datenhaltung widerspiegeln.</p>
</div>
</div>

<div class="div1">
<h2><a name="verwendete-technologien" id="verwendete-technologien"></a>2 Verwendete Technologien</h2>
<p>Dieses Kapitel behandelt im Näheren die im Projekt verwendeten Technologien. Hierunter fallen zum einen die Basis-Technologien, wie:</p>
<ul>
<li>
<p><b>XML:</b> Extented Markup Language für die Datenhaltung.</p>
</li>
<li>
<p><b>DTD:</b> Document Type Definition zur Validierung der XML.</p>
</li>
<li>
<p><b>XSL:</b> Programmiersprache zur Transformation von XML nach Html.</p>
</li>
</ul>
<p>Um nun so manche Problemstellungen lösen zu können, sind für dieses Projekt auch noch weitere Technologien herangezogen worden. Diese sollen dabei die eigentlichen Funktionalitäten der Basis-Technologien unterstützen bzw. erweitern. Es sind hierfür nachfolgende Zwei verwendet worden:</p>
<ul>
<li>
<p>Bootstrap</p>
</li>
<li>
<p>jQuery</p>
</li>
</ul>

<div class="div2">
<h3><a name="xml" id="xml"></a>2.1 XML</h3>
<p> Bei XML handelt es sich, nicht zuletzt durch das Internet, um eine weit verbreitete Auszeichnungssprache zum Austausch von Daten. Das für Web Services sehr beliebte SOAP (Simple Object Access protocoll) verwendet XML als sein Nachrichten Format. Entwickelt wurde die eXtensible Markup Lanuage vom World Wide Web Consortium. Einer der Vorteile des XML-Formats ist, dass es sowohl für Menschen, als auch Maschinen lesbar ist.</p>
<p>Ein XML Dokument besteht aus sog. Elementen. Elemente beginnen entweder mit einem start-tag (&lt;foo>) und enden mit dem zugehörigen end-tag (&lt;/foo>) oder bestehen nur aus einem empty-tag (&lt;foo />). Innerhalb eines start- oder empty-tags können Attribute definiert werden (&lt;foo name="bar" />). Die Zeichen zwischen einem start- und end-tag werden als der Inhalt des Elements bezeichnet. Dieser Inhalt kann wiederum aus anderen Elementen, den sog. Kindelementen, oder einfachem Text bestehen.</p>
<p>Für eine Großzahl der aktuellen Programmiersprachen existieren bereits Bibliotheken welche die Verarbeitung von XML-Dokumenten umfangreich unterstützen. Solche vorgefertigten Programmschnittstellen lassen sich allerdings nur für Well-formed XML-Dokumenten verwenden.</p>
<p>Die Well-formedness eines XML-Dokuments wird durch das Einhalten gewisser Syntaxregeln sichergestellt. Diese Syntaxregeln umfassen unter anderem:
<ul>
<li>Ein einzelnes Wurzelelement umfasst alle anderen Elemente</li>
<li>Das XML-Dokument enthält ausschließlich Unicode-Zeichen</li>
<li>Die Beginn-, Ende- und Leere-Element-Tags sind korrekt geschachtelt</li>
<li>Reservierte Zeichen wie "<" und "&" werden nur vor ihren vorgesehenen Zweck verwendet</li>
</ul>
</p>
<p>Die Struktur eines XML-Dokuments kann mit Hilfe einer document type definition (DTD) beschrieben werden. Solche DTDs werden im folgenden Abschnitt beschrieben.</p>

</div>

<div class="div2">
<h3><a name="dtd" id="dtd"></a>2.2 DTD</h3>
<p>Durch einer document type definition lassen sich Regeln definieren, um den Aufbau eines XML-Dokuments zu beschreiben. Wenn das XML-Dokument alle in der DTD definierten Regeln einhält wird es als Valide bezeichnet.</p>
<p>DTDs werden entweder am Anfang eines XML-Dokuments definiert oder als externe Datei importiert. In unserem Projekt werden DTDs auf folgende Weise in unser Master-XML-Dokument eingebunden:</p>

<div class="exampleInner"><pre>
&lt;!DOCTYPE master [
	&lt;!ENTITY % dtdStations SYSTEM "nv_stations.dtd">
	&lt;!ENTITY % dtdRoutes SYSTEM "nv_routes.dtd">
	&lt;!ENTITY % dtdSchedule SYSTEM "nv_schedules.dtd">
	&lt;!ENTITY % dtdDrivers SYSTEM "nv_drivers.dtd">
	&lt;!ENTITY % dtdVehicles SYSTEM "nv_vehicles.dtd">
	&lt;!ENTITY % dtdTickets SYSTEM "nv_tickets.dtd">
	
	%dtdStations;
	%dtdRoutes;
	%dtdSchedule;
	%dtdDrivers;
	%dtdVehicles;
	%dtdTickets;
	
	&lt;!ELEMENT master (st:stations,dr:drivers,vh:vehicles, 
			rt:routes,sc:schedules, ti:tickets)>
	&lt;!ATTLIST master xmlns:st CDATA #FIXED "nv_stations.dtd"
			xmlns:rt CDATA #FIXED "nv_routes.dtd"
			xmlns:dr CDATA #FIXED "nv_drivers.dtd"
			xmlns:ti CDATA #FIXED "nv_tickets.dtd"
			xmlns:vh CDATA #FIXED "nv_vehicles.dtd"
			xmlns:sc CDATA #FIXED "nv_schedules.dtd">
]>
</pre></div>

<p>Zuerst werden alle externen DTDs als Entität definiert und anschließend über eine Referenz in die Master-XML geladen.</p>
<p>Mit DTDs kann die Schachtelung von Elementen innerhalb eines XML-Dokuments definiert werden. Weiterhin können mit einer document type definition Attribute und deren Werte eingeschränkt werden.</p>
</div>

<div class="div2">
<h3><a name="xslt" id="xslt"></a>2.3 XSLT</h3>
<p>Ist eine Sprache um XML-Dokumente in andere XML-Dokumente oder andere Formate wie HTML zu transformieren. Sogenannte XSLT-Prozessoren erstellen aus einem XML Input und XSLT (Extensible Stylesheet Language Transformations) Code ein neues Dokument.</p>

<center><img src="Bericht%20XML%20Nahverkehr/xslt_process.png" alt="XSLT process" style="width:300px"></center>

<p>Da XSL Stylesheets auch XML Dokumente sind, beginnen sie immer mit einer XML Deklaration wie folgender:</p>

<div class="exampleInner"><pre>
&lt;?xml version="1.0" encoding="UTF-8"?>
</pre></div>

<p>XSLT verwendet XPath Ausdrücke um Schablonen (sog. templates) zu erstellen, welche auf Teile eines Dokuments zutreffen. Sollte eine Schablone auf das Quelldokument passen, wird der Code dieses Templates in das resultierende Dokument eingefügt. Im folgenden Beispiel wird demonstriert, wie ein Template in XSLT definiert wird:</p>

<div class="exampleInner"><pre>
&lt;xsl:template match="/foo">
	&lt;p>bar&lt;/p>
&lt;/xsl:template>
</pre></div>

<p>Das "match" Attribut wird verwendet um via XPath das gewünschte Element im Quelldokument zu finden. Sollte der XSLT Prozessor im Quelldokument ein Element namens "foo" finden, wird im resultierenden Dokument nun</p>

<div class="exampleInner"><pre>
&lt;p>bar&lt;p>
</pre></div>

<p>ausgegeben.</p>

<div class="div2">
<h3><a name="bootstrap" id="bootstrap"></a>2.4 Bootstrap</h3>
<p>Bootstrap ist ein weitverbreitetes Frontend Framework für die Erstellung von Webseiten. Es ermöglicht mit sehr wenig Aufwand ein brauchbares Layout einer Seite zu erstellen. Der Hauptfokus von Bootstrap liegt dabei auf mobilfreundliche Strukturierung von Webseiten. Das sogenannte "responsive design" ermöglicht es, eine Webseite komfortabel auf Geräten jeglicher Größe betrachten zu können. Das folgende Bild soll "responsive design" illustrieren.</p>

<center><img src="Bericht%20XML%20Nahverkehr/responsiveDesign.png" alt="Illustration des Responsive Design"></center>

<p>Für dieses Projekt verwenden wir Bootstrap größtenteils um das Gridsystem zu nutzen. Zusätzlich nutzen wir Bootstrap um unsere rohen XML Daten strukturierter darstellen zu können.</p>

<p>Um sofort mit Bootstrap loslegen zu können, müssen einfach nur die Bootstrap .css und .js Dateien eingebunden werden. Die leichteste Methode ist die Folgende:
</p>
<div class="exampleInner"><pre>
&lt;html>
	&lt;header>
		&lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/
		bootstrap/3.3.1/css/bootstrap.min.css">
		&lt;script src="https://maxcdn.bootstrapcdn.com/
		bootstrap/3.3.1/js/bootstrap.min.js">&lt;/script>	
	&lt;/header>
	&lt;body>
		... Inhalt ...
	&lt;/body>
&lt;/html>
</pre></div>
<p>Nach der Einbindung kann sofort begonnen werden, den HTML Code mit Bootstrapklassen zu modifizieren. Bootstrap unterscheidet zwischen vier Gerätegrößen. Extra Small, Small, Medium und Large Devices. Ein HTML &lt;div> Tag kann durch die entsprechenden Bootstrapklassen modifiziert werden um festzulegen, wie groß das &lt;div> Element sein soll in Abhängigkeit von der Gerätegröße. Die Gerätegrößeklassen werden im folgenden Bild genauer beschrieben.</p>

<center><img src="Bericht%20XML%20Nahverkehr/bootstrapDevices.png" alt="Gerätegrößen von Bootstrap"></center>

<p>
Das Bootstrap Gridsystem besteht aus Containern, Reihen und Spalten. Jeder Container kann mehrere Reihen haben und jeder Reihe kann mehrere Spalten haben. Eine Spalte kann eine bestimmte Breite haben. Bootstrap teilt Reihen in zwölf gleichgroße Teile auf. Jeder Spalte kann dann eine bestimmte Breite zwischen 1 und 12 zugewiesen werden. Das folgende Bild zeigt dieses Prinzip etwas genauer.
</p>

<center><img src="Bericht%20XML%20Nahverkehr/bootstrapGrid.png" alt="Gerätegrößen von Bootstrap"></center>

<p>
Man nehme als Beispiel einen Container, der eine Reihe beinhaltet. Diese Reihe besteht aus drei Spalten. Auf mittelgroßen und sehr großen Desktops sollen die drei "Boxen" nebeneinander sein. Auf kleineren Geräten sollen die drei Spalten zu Zeilen werden, wobei jede Spalte zwölf Einheiten groß sein soll.
</p>
<div class="exampleInner"><pre>
&lt;div class="container">
	&lt;div class="row">
		&lt;div class="col-md-4 col-xs-12">Box1&lt;/div>
		&lt;div class="col-md-4 col-xs-12">Box2&lt;/div>
		&lt;div class="col-md-4 col-xs-12">Box3&lt;/div>
	&lt;/div>
&lt;/div>
</pre>
</div>

</div>

<div class="div2">
<h3><a name="jquery" id="jquery"></a>2.5 jQuery</h3>
<p>
JQuery ist eine clientseitige Javascript Bibliothek. JQuery ermöglicht es u. a. mit wenig Aufwand das DOM (Document Object Model) zu modifizieren. In unserem Projekt haben wir jQuery hauptsächlich dazu verwendet, relevante Teile der XML Daten anzuzeigen und irrelevante Teile zu verstecken. Die Einbindung von jQuery ist genauso einfach wie bei Bootstrap und es muss auch hier nur eine .js Datei eingebunden werden.
</p>

<p>
In jQuery wird auf folgende Weise auf DOM Knoten zugegriffen:
</p>

<div class="exampleInner"><pre>
$(".route") // Zugriff auf bestimmte Klasse
$(".route.station") // Zugriff auf Elemente, welche beide Klassen haben
$("#route") // Zugriff auf bestimmte ID
$("a") // Zugriff auf bestimmtes Element
$('div:not(.route)') // Zugriff auf alle divs, die nicht von der Klasse "route" sind
</pre>
</div>

<p>
JQuery bietet viele Funktionen (wie z. B. show() und hide()) um das DOM zu manipulieren und es würde den Rahmen dieses Berichts sprengen, detailiert darauf einzugehen. Deshalb gibt es lediglich weiter unten einige jQuery Lösungen, die wir für bestimmte Problemstellungen verwendet haben.
</p>

</div>

</div>
</div>

<div class="div1">
<h2><a name="konzept" id="konzept"></a>3 Konzept</h2>
<p>Das Konzept, das schon kurz in <a href="#grundlegendes-konzept">Abschnitt 1.1</a> erläutert wurde, wird in diesem Kapitel nun noch näher differenziert. So ist es zunächst möglich, dieses Projekt in zwei Teilprojekte zu zerlegen. Zu jedem von diesem kann daraufhin ein eingenes Konzept verfasst werden. Diese sind:</p>
<ul>
<li>
<p><b>Datenhaltung:</b> Speicherung von Fahrplänen, Haltenstellen, Fahrzeugen, Routen usw. durch XML.</p>
</li>
<li>
<p><b>Frontend:</b> Nutzerfreundlicher Zugriff auf den Datenbestand mittels einer Html-Seite, generiert durch XSL.</p>
</li>
</ul>
<p>Da jedoch beide nicht vollständig Unabhängig voneinander implementiert werden können, ist es nötig zuerst die Datenhaltung anzulegen. Daraufhin besitzt man die Grundlage das Frontend zu entwickeln.</p>

<div class="div2">
<h3><a name="datenhaltung" id="datenhaltung"></a>3.1 Datenhaltung</h3>
<p>Für die Datenhaltung wurden zunächst einige XML-Dateien angelegt, die jeweils einen Teil aller Tabellen beinhalten. Der Grund hierfür war die Komplexität zu zerbrechen und aufzuteilen. Das Resultat waren daraufhin die folgenden Tabellen:</p>
<ul>
<li>
<p>Haltestellen bzw. -stationen</p>
</li>
<li>
<p>Routen</p>
</li>
<li>
<p>Fahrpläne</p>
</li>
<li>
<p>Ticket- bzw. Fahrpreise</p>
</li>
<li>
<p>Fahrer</p>
</li>
<li>
<p>Fahrzeuge</p>
</li>
</ul>
<p>Um jedoch die einzelen Tabellen bzw. XML-Dateien realisieren zu können, wurden unter anderem Identifikationsnummern als eindeutige Bezeichner eingesetzt. So hat zum Beispiel die Haltestelle "Hauptbahnhof" die Id "F5". Da nun aber auch Routen und Fahrpläne Bezug auf Haltestellen nehmen, kommt es bei der Verwendung von mehreren Dateien zu Problemen.</p>
<p>Aus diesem Grund wurde eine "nv_master.xml" erstellt, die alle eigenständigen Dateien wieder vereinen soll. Es war jedoch nicht möglich nur mit Referenzen auf die Tabellen zu arbeiten. Deshalb haben wir uns für eine Masterdatei entschieden, die eine Konkatination aller Tabellen beinhaltet. Dies bringt zwar den Nachteil mit sich, das Auslagern der Komplexität in viele Dateien nicht machen zu können, hat jedoch den Vorteil Ids uneingeschränkt nutzen zu können.</p>
<p>Da es bei dem Zusammenfügen der einzelnen Dateien zu Konflikten kommen kann, sind Namensräume eingeführt worden. Jede ehemalige XML-Datei hat nun ihren eigenen Namensraum. So ist der Namespace der "nv_station.xml" zum Beispiel "st".</p>

<div class="div3">
<h4><a name="datenhaltung-master" id="datenhaltung-master"></a>3.1.1 Master</h4>
<p>Um es noch einmal zu erwähnen, besteht die Datenhaltung nun aus einer Datei, der sogenannten "nv_master.xml". Hierin befinden sich nun die nachfolgenden Entitäten:</p>
<ul>
<li>
<p>st:stations</p>
</li>
<li>
<p>rt:routes</p>
</li>
<li>
<p>sc:schedules</p>
</li>
<li>
<p>ti:tickets</p>
</li>
<li>
<p>dr:drivers</p>
</li>
<li>
<p>vh:vehicles</p>
</li>
</ul>
<p>Um das noch zu verdeutlichen, vergleiche man dies mit dem nachfolgenden Diagramm.</p>
<center><img src="Bericht%20XML%20Nahverkehr/masterAbhaenigkeiten.png" alt="Entity Relationship Diagramm: Abhängigkeiten des Masters"></center>
</div>

<div class="div3">
<h4><a name="datenhaltung-stations" id="datenhaltung-stations"></a>3.1.2 Stations</h4>
<p>In der Entität Stations werden Haltestellen und -stationen verwaltet. Jede Station besitzt neben den Attributen stationId und name auch weiter Entitäten. Hierunter fallen stationTypes, street und ticketmachines.</p>
<p>Ersteres gibt die Art der Station an, was heißt, welche Fahrzeuge an dieser Station halten können. So kann unterschieden werden, ob es zum Beispiel eine Bushaltestelle oder ein U-Bahnhof ist. Bei street handelt es sich um die Straße, in der diese Haltestelle zu finden ist. Bei ticketmachines können einzelne Automaten hinzugefügt werden, falls die jeweilige Station über ein solches Gerät verfügt.</p>
<p>Der Aufbau und die einzelnen Abhängigkeiten der Entitäten untereinader werden auch noch mal im nachfolgenden Diagramm deutlich.</p>
<center><img src="Bericht%20XML%20Nahverkehr/stationsAbhaenigkeiten.png" alt="Entity Relationship Diagramm: Abhängigkeiten von Stations" style="width: 850px;"></center>
<p>Im nachfolgenden Codebeispiel ist die Station "Fuerth Hardhoehe" gezeigt. Unter anderem erkennt man, dass diese Station sowohl über eine Bus- als auch U-Bahn-Haltestelle verfügt. Zudem erhält man noch Informationen zur Straße der Haltestelle, die in diesem Beispiel "Komotauer Strasse" ist und über die Anzahl der vorhandenen Ticketautomaten, sowie deren Id.</p>
<div class="exampleInner"><pre>
&lt;st:stations&gt;
	...
	&lt;st:station stationId="F1" name="Fuerth Hardhoehe"&gt;
		&lt;st:stationTypes&gt;
			&lt;st:type name="bus"/&gt;
			&lt;st:type name="subway"/&gt;
		&lt;/st:stationTypes&gt;
		&lt;st:street name="Komotauer Strasse"/&gt;
		&lt;st:ticketMachines&gt;
			&lt;st:ticketMachine ticketMachineId="TMF1" /&gt;
		&lt;/st:ticketMachines&gt;
	&lt;/st:station&gt;
	...
&lt;/st:stations&gt;	
</pre></div>
<p>Die Datenstruktur unserer Entität Stations wird in der zugehörigen DTD "nv_stations.dtd" geregelt:</p>
<div class="exampleInner"><pre>
&lt;!ELEMENT st:stations (st:station*)>

&lt;!ELEMENT st:station (st:stationTypes, st:street, st:intersection?,  st:ticketMachines?)>
&lt;!ATTLIST st:station stationId ID #REQUIRED
name CDATA #REQUIRED>

&lt;!ELEMENT st:stationTypes (st:type+)>

&lt;!ELEMENT st:type EMPTY>
&lt;!ATTLIST st:type name (bus | tram | subway | city_train) #REQUIRED>

&lt;!ELEMENT st:street EMPTY>
&lt;!ATTLIST st:street name CDATA #REQUIRED>

&lt;!ELEMENT st:ticketMachines (st:ticketMachine*)>

&lt;!ELEMENT st:ticketMachine EMPTY>
&lt;!ATTLIST st:ticketMachine ticketMachineId ID #REQUIRED>
</pre></div>
<p>
Es wird fesgelegt, dass unsere Entität Stations einen Knoten namens "st:stations" enthält. Dieses Element enthält beliebig viele Kindknoten "st:station".</p> 
<p>Ein solcher Kindknoten kann selbst wiederum folgende Kindknoten besitzen:</p>
<ul>
<li>
<p>"st:stationTypes": genau einmal</p>
</li>
<li>
<p>"st:street": genau einmal</p>
</li>
<li>
<p>"st:ticketMachines": optionaler Kindknoten</p>
</li>
</ul>
<p>Außerdem muss ein "st:station" Element zwingend die Attribute "stationId" (eine eindeutige Kennung) und "name" definieren.</p>
<p>Der Knoten "st:stationTypes" hat mindestens einen weiteren Kindknoten namens "st:type".</p>
<p>"st:type" Elemente haben keine weiteren Kindknoten sondern nur noch ein verpflichtendes Attribut "name", welches ausschließlich die Werte "bus", "tram", "subway" und "city_train" annehmen kann.</p>
<p>Knoten mit dem Namen "st:street" enthalten ebenfalls keine weiteren Kindknoten sondern nur ein obligatorisches Attribut "name".</p>
<p>Falls ein optionaler Kindknoten namens "st:ticketMachines" besteht, enthält dieser beliebig viele Kindknoten "st:ticketMachine", welche ausschließlich ein zwingendes Attribut "ticketMachineId" besitzen.</p>
</div>

<div class="div3">
<h4><a name="datenhaltung-routes" id="datenhaltung-routes"></a>3.1.3 Routes</h4>
<p>Bei den Routen handelt es sich um Linien, wie man das von Bus- oder U-Bahn-Linien kennt. Es sind somit Pfade oder wie schon genannt Routen, die ein einzelnes Fahrzeug abfährt. Auf dem Weg hält es dabei an gewissen Stationen, die in einem Routenplan vermerkt sind. Dieser Routenplan wird in der Entität Routes abgebildet.</p>
<p>Eine Route besitzt neben ihren Attributen routeId und type, was hier zum Beispiel Bus oder U-Bahn sein kann, auch noch weitere Entitäten. Dies ist eine Liste aus Stationen, die einer Route zugeordnet sind. Jede dieser Stationen besitzt eine ReferenzId, welche auf die in <a href="#datenhaltung-stations">Abschnitt 3.1.2</a> erwähnten Stationen verweisen. So müssen die Stationen und dessen Attribute nur an einer Stelle in der Datenhaltung verwaltet werden.</p>
<p>Im Nachfolgendem ist dieser Sachverhalt nochmals anhand eines Diagramms dargestellt.</p>
<center><img src="Bericht%20XML%20Nahverkehr/routesAbhaenigkeiten.png" alt="Entity Relationship Diagramm: Abhängigkeiten von Routes" style="width: 600px;"></center>
<p>In dem nachfolgendem Codebeispiel ist die Route "U1" zu sehen, bei der es sich um eine U-Bahn-Linie handelt. Im Weiteren ist ein Ausschnitt von Stationen angegeben, die jeweils durch die stationId referenziert werden.</p>
<div class="exampleInner"><pre>
&lt;rt:routes&gt;
	...
	&lt;rt:route routeId="U1" type="subway"&gt;
		&lt;rt:station stationId="F1" /&gt;
		&lt;rt:station stationId="F2" /&gt;
		&lt;rt:station stationId="F3" /&gt;
		&lt;rt:station stationId="F4" /&gt;
		...
		&lt;rt:station stationId="N18" /&gt;
		&lt;rt:station stationId="N19" /&gt;
		&lt;rt:station stationId="N20" /&gt;
		&lt;rt:station stationId="N21" /&gt;
	&lt;/rt:route&gt;
	...
&lt;/rt:routes&gt;	
</pre></div>
<p>Die zugehörige beschreibung der Datenstruktur unserer Entität Routes sieht wie folgt aus:</p>
<div class="exampleInner"><pre>
&lt;!ELEMENT rt:routes (rt:route*)>

&lt;!ELEMENT rt:route (rt:station+)>
&lt;!ATTLIST rt:route routeId ID #REQUIRED
type CDATA #REQUIRED>

&lt;!ELEMENT rt:station EMPTY>
&lt;!ATTLIST rt:station stationId IDREF #REQUIRED>
</pre></div>
<p>Der Wurzelknoten unserer Entität Routes nennt sich "rt:routes" und enthält eine beliebige Anzahl von Kindknoten mit dem Namen "rt:route".</p>
<p>Ein solches Element enthält wiederum mindestens einen Kindknoten namens "rt:station" und definiert verbindlich die Attribute "routeId" (die eindeutige Bezeichnung dieser Route) und "type".</p>
<p>Die Elemente "rt:station" definieren zwingend ein Attribut "stationId" welches eine in unserem Modell vorhandene Haltestelle referenziert. Ansonsten sind solche Knoten leer und enthalten keine weiteren Kindknoten.</p>
</div>

<div class="div3">
<h4><a name="datenhaltung-schedules" id="datenhaltung-schedules"></a>3.1.4 Schedules</h4>
<p>Unter dem Begriff Schedules muss man die einzelnen Fahrplanaushänge einer Haltestation verstehen. Jeder einzelne Aushang hat somit eine enge Verbindung zu der Haltestation und einer Route. Es ist das Verbindungsglied zwischen den in <a href="#datenhaltung-stations">Abschnitt 3.1.2</a> und <a href="#datenhaltung-routes">Abschnitt 3.1.3</a> erwähnten Entitäten.</p>
<p>Um so eine Verknüpfung zu realisieren, sind Ids und deren Referenzen nötig. So besitzt die Entität schedule eben zuvor genannte Attribute, man vergleiche hierzu auch nachfolgende Abbildung. Diese lauten somit im Detail:</p>
<ul>
<li>
<p><b>scheduleId:</b> Eindeutige Id für den jeweiligen Fahrplan.</p>
</li>
<li>
<p><b>stationId:</b> Referenz auf eine Id aus der in <a href="#datenhaltung-stations">Abschnitt 3.1.2</a> vorgestellten Entität.</p>
</li>
<li>
<p><b>routeId:</b> Referenz auf eine Id aus der in <a href="#datenhaltung-routes">Abschnitt 3.1.3</a> vorgestellten Entität.</p>
</li>
</ul>
<p>Darüber hinaus besitzt scheudule eine Entität namens depatureTimes. Dies sind die Abfahrtszeiten einer Linie an der jeweiligen Station. Die Entität depatureTimes verfügt zusätzlich noch über ein Attribut names finalStationId, was die Abfahrtsrichtung festlegt. Es wird somit nur eine Endhaltestelle mittels referenzierter Id angegeben. Ein Beispiel hierfür wäre: Die U-Bahn der Linie XY fährt in Richtung Endstation Hauptbahnhof.</p>
<p>Die Entität time ist ein Teil von depatureTimes. Dies sind letztendlich die einzelnen Abfahrtszeiten eines Tages. Zur Vereinfachung bzw. zur Reduktion des Datenbestandes haben wir angenommen, dass die Abfahrtszeiten an jedem Tag in der Woche gleich sind.</p>
<center><img src="Bericht%20XML%20Nahverkehr/schedulesAbhaenigkeiten.png" alt="Entity Relationship Diagramm: Abhängigkeiten von Schedules" style="width: 800px;"></center>
<p>In dem nachfolgendem Codebeispiel ist der Fahrplanaushang "S2" zu sehen, der für die Route "U1" an der Station "F2" gilt. Daraufhin sind die Abfahrtszeiten für beide Fahrtrichtungen angegeben.</p>
<div class="exampleInner"><pre>
&lt;sc:schedules&gt;
	...
	&lt;sc:schedule scheduleId="S2" stationId="F2" routeId="U1"&gt;
		&lt;sc:departureTimes finalStationId="N21"&gt;
			&lt;sc:time&gt;11:32&lt;/sc:time&gt;
			&lt;sc:time&gt;12:32&lt;/sc:time&gt;
			&lt;sc:time&gt;13:32&lt;/sc:time&gt;
		&lt;/sc:departureTimes&gt;
		&lt;sc:departureTimes finalStationId="F1"&gt;
			&lt;sc:time&gt;11:45&lt;/sc:time&gt;
			&lt;sc:time&gt;12:45&lt;/sc:time&gt;
			&lt;sc:time&gt;13:45&lt;/sc:time&gt;
		&lt;/sc:departureTimes&gt;
	&lt;/sc:schedule&gt;
	...
&lt;/sc:schedules&gt;
</pre></div>
<p>Die Struktur unserer Entität Schedules wird durch die DTD "nv_schedules.dtd" definiert:</p>
<div class="exampleInner"><pre>
&lt;!ELEMENT sc:schedules (sc:schedule+)>

&lt;!ELEMENT sc:schedule (sc:departureTimes+)>
&lt;!ATTLIST sc:schedule scheduleId ID #REQUIRED
stationId IDREF #REQUIRED
routeId IDREF #REQUIRED>

&lt;!ELEMENT sc:departureTimes (sc:time+)>
&lt;!ATTLIST sc:departureTimes finalStationId IDREF #REQUIRED>
&lt;!ELEMENT sc:time (#PCDATA)>
</pre></div>
<p>Der Entität-Wurzelknoten "sc:schedules" hat beliebig viele Kindknoten namens "sc:schedule".</p>
<p>Ein solcher Knoten enthält nun mindestens einen Kindknoten "sc:depatureTimes" und definiert zwingend die Attribute "scheduleId", "stationId" und "routeId"(siehe weiter oben in diesem Unterabschnitt).</p>
<p>Ein "sc:departureTimes"-Knoten enthält mindestens einen weiteren Kindknoten namens "sc:time" und definiert verpflichtend das Attribut "finalStationId" mit dem eine im System vorhandene Haltestelle referenziert wird.</p>
<p>Knoten mit dem Namen "sc:time" enthalten lediglich eine Zeichenkette.</p>
</div>

<div class="div3">
<h4><a name="datenhaltung-tickets" id="datenhaltung-tickets"></a>3.1.5 Tickets</h4>
<p>In der Entität tickets werden alle Fahr- bzw. Ticketpreise verwaltet, man vergleiche hierzu auch nachfolgendes Diagramm. So besitzt ein ticket das Attribut type, welches die Dauer bzw. die Gültigkeit der Fahrkarte angibt. Diese können unter anderem sein:</p>
<ul>
<li>
<p><b>single:</b> Ein Ticket für eine einfache Fahrt, ohne Rückfahrt oder ähnlichem.</p>
</li>
<li>
<p><b>day:</b> Ein Tagesticket, gültig für alle Verkehsmittel und in alle Richtungen für einen Tag.</p>
</li>
<li>
<p><b>month:</b> Ein Monatsticket, gültig für alle Verkehsmittel und in alle Richtungen für einen Monat.</p>
</li>
<li>
<p><b>...</b></p>
</li>
</ul>
<p>Desweiteren besizt ticket noch zwei Entitäten. Erstens description, was eine Beschreibung der Ticketform in ein oder zwei Sätzen ist und zweitens fares, was die Tarifzone beschreibt. Hierbei werden meist um den Kern einer Stadt Kreise gelegt. Je weiter man sich nun von diesem Kern mit öffenlichen Verkehsmitteln entfernen möchte, in umso höhere Preisklassen kommt man.</p>
<p>Mit den Attributen in fare werden nun diese Kreise festgelegt. type beschreibt bzw. benennt dabei den jeweiligen Kreis oder Tarifzone. In price wird dann der eigentliche Ticketpreis festgelegt.</p>
<center><img src="Bericht%20XML%20Nahverkehr/ticketsAbhaenigkeiten.png" alt="Entity Relationship Diagramm: Abhängigkeiten von Tickets" style="width: 750px;"></center>
<p>In dem nachfolgendem Codebeispiel sind die Fahrpreise für Tagestickets zu sehen. Die Preise für eine solche Fahrkarte können dabei durch die jeweilige Tarifzone unterscheiden. So kostet ein Tagesticket in der Tarifzone T2 4,60 €.</p>
<div class="exampleInner"><pre>
&lt;ti:tickets&gt;
	...
	&lt;ti:ticket type="day"&gt;
		&lt;ti:description&gt;Valid for remaining day or remaining weekend&lt;/ti:description&gt;
		&lt;ti:fares&gt;
			&lt;ti:fare type="A" price="5,30" /&gt;
			&lt;ti:fare type="T2" price="4,60" /&gt;
			&lt;ti:fare type="T3" price="11,00" /&gt;
			&lt;ti:fare type="T4" price="11,00" /&gt;
		&lt;/ti:fares&gt;
	&lt;/ti:ticket&gt;
	...
&lt;/ti:tickets&gt;
</pre></div>
<p>Der Aufbau der Entität Ticket wird mit der DTD "nv_tickets.dtd" festgelegt:</p>
<div class="exampleInner"><pre>
&lt;!ELEMENT ti:tickets (ti:ticket*)>

&lt;!ELEMENT ti:ticket (ti:description+, ti:fares)>
&lt;!ATTLIST ti:ticket type (single | day | month) #REQUIRED>

&lt;!ELEMENT ti:description (#PCDATA)>

&lt;!ELEMENT ti:fares (ti:fare+)>

&lt;!ELEMENT ti:fare EMPTY>
&lt;!ATTLIST ti:fare type CDATA #REQUIRED
price CDATA #REQUIRED>
</pre></div>
<p>Als Wurzelelement dieser DTD wird ein Knoten namens "ti:tickets" definiert. Dieser hat eine beliebige Anzahl an Kindknoten mit dem Namen "ti:ticket".</p>
<p>Ein solches Element "ti:ticket" hat wiederum genau ein Kindelement "ti:description" und genau ein Kindelement "ti:fares". Außerdem muss jedes "ti:ticket" Element unbedingt das Attribut "type" definieren welches die Werte "single", "day" und "month" annehmen kann (siehe weiter oben in diesem Unterabschnitt).</p>
<p>Ein "ti:description" Knoten enthält lediglich eine Zeichenkette und keine Attribute.</p>
<p>Elemente mit dem Namen "ti:fares" enthalten mindestens einen weiteren Kindknoten namens "ti:fare"</p>
<p>Solch ein "ti:fare" Element enthält keine weiteren Kindknoten muss aber unbedingt die Attribute "type" und "price" definieren. Durch das Attribut "type" wird die Bezeichnung der Tarifstufe spezifiziert und das Attribut "price" enthält den zugehörigen Preis für dieses Ticket in dieser Tarifzone.</p>
</div>

<div class="div3">
<h4><a name="datenhaltung-drivers" id="datenhaltung-drivers"></a>3.1.6 Drivers</h4>
<p>Die Entität drivers beinhaltet alle Angestellten des Nahverkehrssystems, die die Lizenz haben ein Fahrzeug zu bedienen. Man vergleiche dies hierzu auch mit nachfolgender Abbildung. Es werden in dieser Entity alle Relevanten Informationen über die Fahrer abgespeichert. So besitzt die Entität Driver zunächst die folgenden Attribute:</p>
<ul>
<li>
<p><b>driverId:</b> Eine eindeutige Id.</p>
</li>
<li>
<p><b>firstname:</b> Der Vorname des Fahrers.</p>
</li>
<li>
<p><b>Lastname:</b> Der Nachname des Fahrers.</p>
</li>
<li>
<p><b>phone:</b> Die private Telefonnummer des Fahrers.</p>
</li>
</ul>
<p>Desweiteren besitzt driver noch Entitäten wie vehicle und homeaddress. Letzeres verwaltet die Adresse des Fahrers. Hierzu ist diese in weiteren Entitäten aufgeteilt:</p>
<ul>
<li>
<p><b>street:</b> Straße</p>
</li>
<li>
<p><b>houseNo:</b> Hausnummer</p>
</li>
<li>
<p><b>areacode:</b> Postleitzahl</p>
</li>
<li>
<p><b>town:</b> Ort</p>
</li>
</ul>
<p>Die Letzte Entität ist nun vehicle. Dies können dabei mehrere sein und geben jeweils an, welche Typ von Fahrzeugen der jeweilige Fahrer bedienen darf bzw. wofür eine entsprechende Lizenz vorliegt. Diese Typen können zum Beispiel sein: subway, bus, tram ...</p>
<center><img src="Bericht%20XML%20Nahverkehr/driversAbhaenigkeiten.png" alt="Entity Relationship Diagramm: Abhängigkeiten von Drivers" style="width: 850px;"></center>
<p>In dem nachfolgendem Codebeispiel ist ein Fahrer mit dem Namen "Max Mustermann" zu sehen. Dieser Angestellte hat dabei ausschließlich eine Lizenz zum Führen eines Busses. Weiterhin ist auch noch die Adresse des Fahrers ersichtlich.</p>
<div class="exampleInner"><pre>
&lt;dr:drivers&gt;
	...
	&lt;dr:driver driverId="D2" firstname="Max" lastname="Mustermann" phone="0172555455"&gt;
		&lt;dr:vehicle type="bus"/&gt;
		&lt;dr:homeaddress&gt;
			&lt;dr:street&gt;Breitscheidstraße&lt;/dr:street&gt;
			&lt;dr:houseNo&gt;131&lt;/dr:houseNo&gt;
			&lt;dr:areacode&gt;90459&lt;/dr:areacode&gt;
			&lt;dr:town&gt;Nuernberg&lt;/dr:town&gt;
		&lt;/dr:homeaddress&gt;
	&lt;/dr:driver&gt;
	...
&lt;/dr:drivers&gt;
</pre></div>
<p>Die zugehörige DTD "nv_drivers.dtd" definiert die Struktur der Entität Drivers:</p>
<div class="exampleInner"><pre>
&lt;!ELEMENT dr:drivers (dr:driver*)>

&lt;!ELEMENT dr:driver (dr:vehicle+, dr:homeaddress)>
&lt;!ATTLIST dr:driver firstname CDATA #REQUIRED
lastname CDATA #REQUIRED
phone CDATA #REQUIRED
driverId ID #REQUIRED>

&lt;!ELEMENT dr:vehicle EMPTY>
&lt;!ATTLIST dr:vehicle type CDATA #REQUIRED>

&lt;!ELEMENT dr:homeaddress (dr:street, dr:houseNo, dr:areacode, dr:town)>

&lt;!ELEMENT dr:street (#PCDATA)>

&lt;!ELEMENT dr:houseNo (#PCDATA)>

&lt;!ELEMENT dr:areacode (#PCDATA)>

&lt;!ELEMENT dr:town (#PCDATA)>
</pre></div>
<p>Das Wurzelelement der Entität Drivers hat den Namen "dr:drivers" und besitzt eine beliebige Anzahl von Kinderknoten mit dem Namen "dr:driver".</p>
<p>Ein "dr:driver" Element hat mindestens einen Kindknoten "dr:vehicle" und genau einen Kindknoten "dr:homeadress". Weiterhin werden im Knoten "dr:driver" verpflichtend die Attribute "firstname", "lastname", "phone" und "driverId" (siehe weiter oben in diesem Unterabschnitt) definiert.</p>
<p>Das Element "vehicle" definiert obligatorisch das Attribut "type" und ist ein ansonsten leerer Knoten.</p>
<p>Der Knoten "dr:homeaddress" enthält jeweils einen Kindknoten "dr:street", "dr:houseNo", "dr:areacode" und "dr:town" (siehe weiter oben in diesem Unterabschnitt). Alle diesen Kindknoten enthalten lediglich Zeichenketten und keinerlei Attribute oder weitere Kindknoten.
</div>

<div class="div3">
<h4><a name="datenhaltung-vehicles" id="datenhaltung-vehicles"></a>3.1.7 Vehicles</h4>
<p>Die Beschreibungen eines Fahrzeuges wurden recht einfach gehalten und bestehen an sich nur aus einer einzigen Entität. Diese hat jedoch einige Attribute:</p>
<ul>
<li>
<p><b>type:</b> Der Typ eines Fahrzeuges, wie zum Beispiel: subway, bus, tram, city-train ...</p>
</li>
<li>
<p><b>licensePlate:</b> Das eindeutige Nummernschild des jeweiligen Fahrzeugs.</p>
</li>
<li>
<p><b>capacity:</b> Die maximale Anzahl an zugelassenen Passagieren.</p>
</li>
<li>
<p><b>buildYear:</b> Das Baujahr des jeweiligen Fahrzeugs.</p>
</li>
</ul>
<center><img src="Bericht%20XML%20Nahverkehr/vehiclesAbhaenigkeiten.png" alt="Entity Relationship Diagramm: Abhängigkeiten von Vehicles" style="width: 400px;"></center>
<p>In dem nachfolgendem Codebeispiel sind einige Fahrzeuge aus dem Nürnberger Fuhrpark zu sehen. So besitzt zum Beispiel der Bus mit dem Kennzeichen "N-BU-101" eine maximale Passagieranzahl von "80" usw.</p>
<div class="exampleInner"><pre>
&lt;vh:vehicles&gt;
	...
	&lt;vh:vehicle type="bus"
				licensePlate="N-BU-100"
				capacity="50"
				buildYear="1999"/&gt;
	&lt;vh:vehicle type="bus"
				licensePlate="N-BU-101"
				capacity="80"
				buildYear="2005"/&gt;
	&lt;vh:vehicle type="subway"
				licensePlate="N-SU-100"
				capacity="310"
				buildYear="2000"/&gt;
	...
&lt;/vh:vehicles&gt;
</pre></div>
<p>Die Struktur der Entität Vehicles wird in der zugehörigen DTD "nv_vehicles.dtd" definiert:</p>
<div class="exampleInner"><pre>
&lt;!ELEMENT vh:vehicles (vh:vehicle*)>

&lt;!ELEMENT vh:vehicle EMPTY>
&lt;!ATTLIST vh:vehicle type (bus | tram | subway | city_train) #REQUIRED
licensePlate ID #REQUIRED
capacity CDATA #REQUIRED
buildYear CDATA #REQUIRED>
</pre></div>
<p>Der Wurzelknoten der Entität Vehicle hat den Namen "vh:vehicles". Dieser Wurzelknoten hat eine beliebige Anzahl an Kindknoten mit dem Namen "vh:vehicle".</p>
<p>Ein "vh:vehicle" Knoten ist ein an sich leeres Element definiert allerdings verpflichtend die Attribute  "type", "licensePlate", "capacity und "buildYear" (siehe weiter oben in diesem Unterabschnitt).</p>
</div>
</div>

<div class="div2">
<h3><a name="frontend" id="frontend"></a>3.2 Frontend</h3>

<div style="background-color:#E3A6A6;">
<p style="margin:50px">
<font color="red"><b>WICHTIG: Die Weboberfläche funktioniert nur in Mozilla Firefox richtig. Unter Google Chrome können die DTDs nicht richtig geladen werden (siehe folgendes Bild).</b></font>
<center><img src="Bericht%20XML%20Nahverkehr/chromeError.png" alt="Index Mockup"></center>
</p>
</div>

<p> 
Nach der Festlegung unseres Datenmodells musste anschließend die Darstellung dieser Daten konzeptioniert werden. Wir hatten uns entschieden zunächst Mockups anzufertigen, um uns auf ein bestimmtes Layout zu einigen. Ursprünglich war geplant, für jeden "Aspekt" unseres Datenmodells eine .html Datei mithilfe von XSLT zu erzeugen. Als die Mockups entstanden sind, war noch nicht ganz klar wie die Mockups mit XSLT umgesetzt werden sollten. So waren wir uns noch nicht bewusst, wo wir bei der Darstellung auf Probleme stoßen würden. Aus diesem Grund ist unsere tatsächliche Umsetzung der grafischen Oberfläche zwar den Mockups visuell ähnlich, jedoch "unter der Haube" völlig anders.
</p>

<p>
Im nächsten Unterabschnitt werden zunächst die Mockups besprochen und danach die tatsächliche Umsetzung der Oberfläche beleuchetet.
</p> 

<div class="div3">
<h4><a name="frontend-mockups" id="frontend-mockups"></a>3.2.1 Mockups</h4>

<p>
Im Folgenden werden die Mockups beschrieben und die Ideen dahinter näher erleutert.
</p>

<center><img src="Bericht%20XML%20Nahverkehr/indexMockup.png" alt="Index Mockup"></center>

<p>
Von der zentralen index.html unserer Oberfläche wollten wir Buttons zur Verfügung stellen, um auf alle Unterseiten zu gelangen. Diese Unterseiten sollten jeweils einen bestimmten Teil unseres Datenmodells darstellen. Die Unterseiten sollten bei relevanten Verknüpfungen auch aufeinander verlinken.
</p>

<center><img src="Bericht%20XML%20Nahverkehr/routesMockup.png" alt="Routes Mockup"></center>

<p>
Die Routen sollten in einer Liste dargestellt werden. Zu jeder Route sollte es einen Link auf die entsprechenden Stations der jeweiligen Route geben.
</p>

<center><img src="Bericht%20XML%20Nahverkehr/stationsMockup.png" alt="Stations Mockup"></center>

<p>
Die Stations sollten auf ähnliche Weise wie die Routes in einer großen Listen angezeigt werden. Zu jeder Station sollte es einen Link auf die entsprechenden Fahrpläne dieser Station geben. Zusätzlich sollte es eine Suchleiste geben, die es ermöglicht Stations mithilfe von Schlüsselwörtern zu filtern.
</p>

<center><img src="Bericht%20XML%20Nahverkehr/schedulesMockup.png" alt="Schedules Mockup"></center>

<p>
Bei den Schedules sollten zum einen die Details der Station (station type, street, ticket machines) angezeigt werden. Weiter unten sollten die Fahrpläne für die verschiedenen Linien dieser Haltestelle angezeigt werden.
</p>

<center><img src="Bericht%20XML%20Nahverkehr/ticketsMockup.png" alt="Tickets Mockup"></center>

<p>
Die Tickets sollten ebenfalls in einer Liste ausgegeben werden. Dabei sollten alle relevanten Ticketinformationen angezeigt werden. Die Tickets in irgendeiner Art und Weise mit den anderen Datenmodellen zu verbinden war nicht geplant.
</p>

</div>

<div class="div3">
<h4><a name="frontend-aufbau" id="frontend-aufbau"></a>3.2.2 Aufbau</h4>

<p>
Zunächst wollten wir uns bei der Umsetzung der Oberfläche an die Mockups halten. Wir hatten damit aber einige Probleme. Da wir die ID-Validierung korrekt verwenden wollten, waren wir gezwungen statt vieler einzelner XML dateien, eine große master.xml zu verwenden. Danach wollten wir zwar die master.xml behalten und die einzelnen XML-Dateien in die master.xml per Entities einbinden, was aber aus unbekannten Gründen nicht funktioniert hat. Wir waren also gezwungen, eine riesige master.xml zu verwalten.
</p>

<p>
Wir wollten herausfinden, was die schnellste Möglichkeit ist, unser Datenmodell zu veranschaulichen und ein gewisses Maß an Interaktion in die Oberfläche zu bringen. Nach einiger Überlegung hatten wir uns dann darauf geeinigt, eine einzige HTML-Datei zu erzeugen und alle XML-Daten auf einmal zu laden. Um nur die gerade relevanten Daten anzuzeigen war eine Logik nötig, die wir mit jQuery umgesetzt haben. Zusätzlich war eine Logik für die Auflösung von IDs in Namen nötig. Diese haben wir ebenfalls mit jQuery umgesetzt.
</p>

<center><img style="width:80%;" src="Bericht%20XML%20Nahverkehr/indexGUI.png" alt="Index GUI"></center>
<p> 
Beim Aufruf der nv_master.xml im Browser erscheint als Erstes die Willkommensmeldung und die Menüleiste.
Wie bereits erwähnt, wird sofort die gesamte XML-Datei geladen und nur gerade relevante teile der XML-Datei angezeigt. Dies wird durch eine von uns erstelle Klasse "static" ermöglicht. Unsere jQuery Logik versteckt alle &lt;div> Elemente die nicht von der Klasse "static" sind. Dies geschieht wie folgt:
</p>

<div class="exampleInner"><pre>
// hide everything except static page elements
$('div:not(.static)').hide(); 
</pre></div>

<p>
Mit einem Klick auf "Nuremberg Local Transport" im linken oberen Eck kann man jederzeit zur Willkommensseite zurückgelangen.
</p>

<center><img style="width:80%;" src="Bericht%20XML%20Nahverkehr/routesGUI.png" alt="Routes GUI"></center>
<p>
Die Routen werden untereinander in einer Liste angezeigt. Für jede Route wird angezeigt, von welchem Typ sie ist. Für jeden Eintrag wird ein &lt;a>-Tag verwendet. Diesem Tag werden per XSL (mit xsl:attribute) Klassen zugewiesen. Zusätzlich zum Schlüsselwort routeDetailToggle und einer Bootstrapklasse, wird auch die Routen Id als Klasse zugewiesen (siehe folgenden Code).
</p>

<p><div class="exampleInner"><pre>
&lt;xsl:for-each select="rt:route">
    &lt;a href="#">
        &lt;xsl:attribute name="class">
            	&lt;xsl:value-of select="@routeId"/> routeDetailToggle list-group-item
        &lt;/xsl:attribute>
        &lt;xsl:value-of select="@routeId"/>
        &lt;span class="badge">
            &lt;xsl:value-of select="@type"/>
        &lt;/span>
    &lt;/a>
&lt;/xsl:for-each>
</pre></div></p>

<p>
Sobald auf eine Route geklickt wird, greift unsere jQuery Logik ein und zeigt zunächst alle Station Ids dieser Route in einer Liste an. Die Gruppen von Station Ids erhalten per xml:attribute neben einer Bootstrapklasse zusätzlich eine klasse "routeDetails" um sie als Stations innerhalb einer Route kenntlich zu machen und die Id der Route als zusätzliche Klasse, um erkennen zu könnnen, welcher Route diese Stations angehören . Jeder einzelnen Station wird als Klasse die entsprechende stationId, die Schlüsselwörter stationDetailToggle (um später die Schedules aufrufen zu können) und station (um die stationIds in tatsächliche Namen auflösen zu können) zugewiesen (siehe folgender Code).
</p>

<p><div class="exampleInner"><pre>
&lt;xsl:for-each select="rt:route">
    &lt;div>
        &lt;xsl:attribute name="class">
            &lt;xsl:value-of select="@routeId"/> 
            	routeDetails col-md-4 col-xs-12
        &lt;/xsl:attribute>
        &lt;!-- details for each route -->
        &lt;div class="panel panel-default static">
            &lt;div class="panel-heading static">Stations&lt;/div>
            &lt;div>
                &lt;xsl:attribute name="class">
                    &lt;xsl:value-of select="@routeId"/> routeDetails list-group
                &lt;/xsl:attribute>
                &lt;xsl:for-each select="rt:station">
                    &lt;a href="#">
                        &lt;xsl:attribute name="class">
                            &lt;xsl:value-of select="@stationId"/> 
                            stationDetailToggle 
                            station 
                            list-group-item
                        &lt;/xsl:attribute>
                        &lt;img width="20px" src="img/haltestelle.svg"/>&#160;
			&lt;stationMark>&lt;xsl:value-of select="@stationId"/>&lt;/stationMark>
                    &lt;/a>
                &lt;/xsl:for-each>
            &lt;/div>
        &lt;/div>
    &lt;/div>
&lt;/xsl:for-each>
</pre></div></p>            

<p>
Beim Klick auf eine Route findet jQuery zunächst heraus, auf welche Route geklickt wurde, um später die Möglichkeit zu haben nur diejenigen Fahrpläne für eine Haltestelle anzuzeigen, die der vorher angeklickten Linie (Route) entsprechen. Es werden, falls  vorher auf eine andere Route geklickt wurde, alle Fahrpläne (Schedules) ausgeblendet und anschließend nur diejenigen Station Ids angezeigt, die der Route entsprechen. Da die Station Ids aber für einen Benutzer relativ unnütz sind, in unserem Datenmodell aber innerhalb einer Route nur Ids von Stations vorhanden sind, müssen die Ids irgendwie in tatsächliche Haltestellennamen umgewandelt werden (siehe folgenden Code).
</p>

<p><div class="exampleInner"><pre>
// show stations within a route
$(".routeDetailToggle").click(function(){
	var route = $(this).attr('class');
	route = route.replace(" routeDetailToggle", "");
	route = route.replace(" list-group-item", "");
	selectedRoute = route;

	// hide any existing schedules that are being shown
	$(".schedule").hide(); 

	// only show stations of the selectd route
	$('.routeDetails').hide();
	var routeDetails = $('.' +route + '.routeDetails');
	routeDetails.show();
	
	// turn station IDs to station names
	var stationIdArray = routeDetails.find('stationMark');
	$.each(stationIdArray, function(){$(this).text(getStationNameFromId($(this).text()))});
});

function getStationNameFromId(stationId){
  var name = null;
  name = $('.' + stationId + '.station').attr('name');
  // replace all spaces with real spaces
  return name == null ? stationId : name.replace(/%20/g, " ");
}
</pre></div></p>

<p>
Die Fahrpläne für jede Station werden nach dem Klick auf die jeweilige Station angezeigt. Es werden dabei nur diejenigen Fahrpläne angezeigt, die zur Route gehören, die vorher geklickt wurde, um die entsprechenden Stations anzuzeigen (dafür ist die Variable selectedRoute nötig). Es werden dabei alle &lt;departureTimes>-Elemente für jedes &lt;schedule>-Element angezeigt. Da es bei Endhaltestellen nur eine Richtung gibt, gibt es nur ein &lt;departureTimes>-Elemente und es wird auch nur dieses angezeigt.
</p>

<center><img style="width:80%;" src="Bericht%20XML%20Nahverkehr/stationsGUI.png" alt="Stations GUI"></center>
<p>
Beim Klick auf "Stations" in der Navbar erscheinen, unabhängig von der Route, alle Haltestellen, die im Datenmodell hinterlegt sind. Dabei werden für jede Haltestelle detailiertere Informationen angezeigt, wie die tatsächliche Straße an der die Haltestelle liegt, die Typen der öffentlichen Verkehrsmittel, die an der jeweiligen Haltestelle verfügbar sind und die Anzahl der Fahrkartenautomaten.
</p>

<p>
Ein spezielles Feature des Station-View ist die Filterleiste. Mit dieser ist es möglich nach allen Begriffen zu Filtern. Es kann nach Haltestellennamen, Straßennamen, Stationstyp oder Anzahl der Fahrkartenautomaten gefiltert werden. Die Mechanik ist sehr einfach, da sie lediglich in den Zeilen der Tabellen nach Zeichenketten sucht, welche den Suchbegriff teilweise oder vollständig enthalten (siehe folgenden Code). Dabei werden Reihen, welche den Suchbegriff nicht enthalten versteckt. Der Filter aktualisiert die Haltestellen bei jedem Tastendruck.
</p>

<p><div class="exampleInner"><pre>
$(".stationFilter").keyup(function(){
   inp = $('.stationFilter').val()
   $("tr:not(:has(>th))").each(function() {
      if (~$(this).text().toLowerCase().indexOf( inp.toLowerCase() ) ) {
         $(this).show();
      } else {
         $(this).hide();
      }
    });
});
</pre></div></p>

<center><img style="width:80%;" src="Bericht%20XML%20Nahverkehr/ticketsGUI.png" alt="Tickets GUI"></center>
<p>
Die Fahrkarten werden mithilfe von Bootstrap lediglich etwas aufgehübscht. Es gibt hierzu keine erwähnenswerte Logik.
</p>

<center><img style="width:80%;" src="Bericht%20XML%20Nahverkehr/driversGUI.png" alt="Drivers GUI"></center>
<p>
Die verschiedenen Fahrer, welche im Datenmodell hinterlegt sind, erscheinen zunächst in einer Liste. Für jeden Fahrer werden grundlegende Informationen angezeigt (siehe vorheriges Bild). Beim Klick auf einen Fahrer werden erweiterte Informationen für diesen angezeigt. Zusätzlich zu den grundlegenden Information wird dann auch die Adresse des jeweiligen Fahrers angezeigt. Hier sind Erweiterungen denkbar. Die Anzeigelogik der Fahrer ist ähnlich der Anzeigelogik der Routen.
</p>

<center><img style="width:80%;" src="Bericht%20XML%20Nahverkehr/vehiclesGUI.png" alt="Vehicles GUI"></center>
<p>
Bei den Fahrzeugen gibt es, genau wie bei den Fahrkarten, keine besondere Logik. Es werden einfach die Daten aus dem Datenmodell angezeigt. Hier ist jedoch eine Erweiterung denkbar, welche bestimmte Fahrer mit bestimmten Fahrzeugen verbindet.
</p>

</div>

</div>
</div>

<div class="div1">
<h2><a name="fazit" id="fazit"></a>4 Fazit</h2>
<p>Zusammenfassend ist zu sagen, dass dieses Projekt einen guten Einblick in die Gestaltung und Verwendung von XML als Datenhaltung ermöglichte. Auch auftretende Probleme, wie dateiübergreifende Ids, die erst durch eine Master-Datei in korrekter Weise funktionierten, konnten gelöst werden. Dies schaffte ein tiefgreifendes Verständnis über den richtigen Aufbau einer XML-Datei.
</p>

<p>
Weiterhin ist zu sagen, dass uns die Transformation von XML nach Html anfangs vor große Probleme gestellt hat, da wir nicht die, zuvor als Mockups festgelegten, Views in dieser Art und Weise umsetzen konnten. Jedoch ist es uns gelungen, auch dieses Problem zu lösen, in dem wir zusätzliche Technologien wie jQuery, in unserem Projekt mit verwendeten.
</p>

<p>
Letztlich war es also möglich mit doch relativ geringem Aufwand sowohl eine Datenhaltung, als auch eine graphische Abfrage dieser Daten zu realisieren.
</p>

</div>
    
</div>

<br><br><br><br><br>
<br><br><br><br><br>

<div class="back">
<div class="div1">
<h2><a name="quellen" id="quellen"></a>A Quellen</h2>
<p>[1] <a href="http://en.wikipedia.org/wiki/XML">http://en.wikipedia.org/wiki/XML</a></p>
<p>[2] <a href="http://en.wikipedia.org/wiki/Document_type_definition">http://en.wikipedia.org/wiki/Document_type_definition</a></p>
<p>[3] <a href="http://en.wikipedia.org/wiki/XSLT">http://en.wikipedia.org/wiki/XSLT</a></p>
<p>[4] <a href="http://connect.icrossing.co.uk/mobile-optimisation-strategy-responsive-design-or-standalone-site_10412">http://connect.icrossing.co.uk/mobile-optimisation-strategy-responsive-design-or-standalone-site_10412</a></p>
<p>[5] <a href="http://getbootstrap.com/">http://getbootstrap.com/</a></p>
<p>[6] <a href="http://jquery.com/">http://jquery.com/</a>
</div>
</div>

</body>
</html>